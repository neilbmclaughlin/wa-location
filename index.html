<!DOCTYPE html>
<html>
<head>
  <title>UK Geological Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 100vh; }
    .layer-control {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="layer-control">
    <label>
      <input type="checkbox" id="bgsToggle"> BGS Hydrogeology
    </label>
    <br>
    <label>
      <input type="checkbox" id="waterToggle" checked> Water Availability at Q95
    </label>
    <br>
    <label>
      <input type="checkbox" id="monitoringToggle"> Water Monitoring Sites
    </label>
    <br>
    <label>
      <input type="checkbox" id="waterbodyToggle" checked> Waterbody Features
    </label>
    <div id="waterLegend" style="margin-top: 10px;">
      <div><strong>Water Availability:</strong></div>
      <div id="legendItems"></div>
    </div>
  </div>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search)
    const lat = urlParams.get('lat')
    const lng = urlParams.get('lng')
    const postcode = urlParams.get('postcode')
    
    const map = L.map('map').setView([lat || 54.5, lng || -2.5], lat ? 12 : 6);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);
    
    // Add pin if coordinates are provided
    if (lat && lng) {
      const marker = L.marker([lat, lng]).addTo(map);
      marker.bindPopup(`<b>Postcode:</b> ${postcode || 'Unknown'}<br><b>Water Availability:</b> Loading...`);
      
      // Query layer metadata at pin location
      const queryMetadata = async () => {
        try {
          console.log('Fetching polygons within 1km of:', lat, lng);
          
          // Get all polygons within 1km using WFS
          const response = await fetch(`/water-features-radius?lat=${lat}&lng=${lng}&radius=1000`);
          const data = await response.json();
          
          let popupContent = `<b>Postcode:</b> ${postcode || 'Unknown'}<br>`;
          
          if (data.features && data.features.length > 0) {
            popupContent += `<b>Nearby Polygons:</b> ${data.features.length}<br>`;
            
            // Collect all unique ea_wb_id values
            const waterbodyIds = [...new Set(
              data.features
                .map(feature => feature.properties.ea_wb_id)
                .filter(id => id)
            )];
            
            // Fetch waterbody features for all IDs
            const waterbodyFeatures = [];
            for (const id of waterbodyIds) {
              try {
                const waterbodyResponse = await fetch(`/waterbody/${id}`);
                const waterbodyData = await waterbodyResponse.json();
                waterbodyFeatures.push(...waterbodyData.features);
              } catch (error) {
                console.error(`Failed to load waterbody ${id}:`, error);
              }
            }
            
            // Add all waterbody features to map as a single layer
            if (waterbodyFeatures.length > 0) {
              waterbodyLayer = L.geoJSON(waterbodyFeatures, {
                style: (feature) => {
                  const geometryType = feature.properties['geometry-type'];
                  const type = geometryType ? geometryType.split('/').pop() : '';
                  
                  if (type === 'Catchment') {
                    return {
                      color: '#000000',
                      weight: 2,
                      opacity: 0.8,
                      fillOpacity: 0.1
                    };
                  } else if (type === 'RiverLine') {
                    return {
                      color: '#0066cc',
                      weight: 3,
                      opacity: 0.8,
                      fillOpacity: 0
                    };
                  } else {
                    return {
                      color: '#0066cc',
                      weight: 2,
                      opacity: 0.8,
                      fillOpacity: 0.3
                    };
                  }
                }
              });
              
              if (document.getElementById('waterbodyToggle').checked) {
                waterbodyLayer.addTo(map);
              }
              
              console.log(`Added ${waterbodyFeatures.length} waterbody features to map`);
              popupContent += `<b>Waterbody Features:</b> ${waterbodyFeatures.length}<br>`;
            }
          } else {
            popupContent += `<b>Water Availability:</b> No polygons found within 1km`;
          }
          
          marker.setPopupContent(popupContent);
        } catch (error) {
          console.error('Metadata error:', error);
          marker.setPopupContent(`<b>Postcode:</b> ${postcode || 'Unknown'}<br>Error loading metadata`);
        }
      };
      
      queryMetadata();
    }
    
    const wmsLayer = L.tileLayer.wms('http://localhost:3000/wms', {
      layers: 'Hydrogeology',
      format: 'image/png',
      transparent: true,
      attribution: '© BGS',
      opacity: 1
    });
    
    // Add monitoring sites layer using GeoJSON
    let monitoringSitesLayer;
    let waterbodyLayer;
    fetch('/monitoring-sites')
      .then(response => response.json())
      .then(data => {
        monitoringSitesLayer = L.geoJSON(data, {
          pointToLayer: (feature, latlng) => {
            return L.circleMarker(latlng, {
              radius: 4,
              fillColor: '#ff7800',
              color: '#000',
              weight: 1,
              opacity: 1,
              fillOpacity: 0.8
            });
          },
          onEachFeature: (feature, layer) => {
            if (feature.properties) {
              let popupContent = '<b>Monitoring Site:</b><br>';
              for (const [key, value] of Object.entries(feature.properties)) {
                popupContent += `${key}: ${value}<br>`;
              }
              layer.bindPopup(popupContent);
            }
          }
        });
      });
    
    // Color mapping for water availability
    const colorMap = {
      'red': '#ff0000',
      'yellow': '#ffff00',
      'green': '#00ff00',
      'grey': '#808080',
      'unknown': '#cccccc'
    };
    
    function getColor(properties) {
      const value = properties.camscdsq95;
      const lowerValue = value ? value.toLowerCase() : 'unknown';
      return colorMap[lowerValue] || colorMap['unknown'];
    }
    
    // Build legend from color map
    const legendItems = document.getElementById('legendItems');
    Object.entries(colorMap).forEach(([label, color]) => {
      if (label !== 'unknown') {
        const item = document.createElement('div');
        item.style.cssText = 'display: flex; align-items: center; margin: 2px 0;';
        item.innerHTML = `<div style="width: 15px; height: 15px; background: ${color}; margin-right: 5px;"></div><span>${label}</span>`;
        legendItems.appendChild(item);
      }
    });
    
    // Load water availability as WMS layer
    const waterLayer = L.tileLayer.wms('http://localhost:3000/water-wms', {
      layers: 'Resource_Availability_at_Q95',
      format: 'image/png',
      transparent: true,
      attribution: '© Environment Agency',
      opacity: 0.7
    }).addTo(map);
    
    // Add click handler for GetFeatureInfo
    map.on('click', async (e) => {
      const bounds = map.getBounds();
      const size = map.getSize();
      const point = map.latLngToContainerPoint(e.latlng);
      
      try {
        const url = `/water-availability?bbox=${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}&width=${size.x}&height=${size.y}&x=${Math.round(point.x)}&y=${Math.round(point.y)}`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.features && data.features.length > 0) {
          const feature = data.features[0];
          let popupContent = '<b>Water Availability Data:</b><br>';
          
          for (const [key, value] of Object.entries(feature.properties)) {
            popupContent += `${key}: ${value}<br>`;
          }
          
          // Fetch waterbody features if ea_wb_id exists
          if (feature.properties.ea_wb_id) {
            try {
              const waterbodyResponse = await fetch(`/waterbody/${feature.properties.ea_wb_id}`);
              const waterbodyData = await waterbodyResponse.json();
              
              // Extract waterbody feature names with geometry types
              const featureNames = waterbodyData.features
                .map(f => {
                  const name = f.properties.name || f.properties.NAME;
                  const geometryType = f.properties['geometry-type'];
                  const type = geometryType ? geometryType.split('/').pop() : '';
                  return name ? `${name} (${type})` : null;
                })
                .filter(name => name);
              
              if (featureNames.length > 0) {
                popupContent += `<b>Waterbody Features:</b><br>`;
                featureNames.forEach(name => {
                  popupContent += `• ${name}<br>`;
                });
              }
            } catch (error) {
              console.error('Failed to load waterbody data:', error);
            }
          }
          
          L.popup().setLatLng(e.latlng).setContent(popupContent).openOn(map);
        } else {
          // Show a popup indicating no data found
          L.popup().setLatLng(e.latlng).setContent('<b>No water availability data found at this location</b>').openOn(map);
        }
      } catch (error) {
        console.error('GetFeatureInfo error:', error);
      }
    });
    
    wmsLayer.on('tileerror', (e) => console.error('WMS tile error:', e));
    
    document.getElementById('bgsToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        map.addLayer(wmsLayer);
      } else {
        map.removeLayer(wmsLayer);
      }
    });
    
    document.getElementById('waterToggle').addEventListener('change', (e) => {
      const legend = document.getElementById('waterLegend');
      if (e.target.checked) {
        map.addLayer(waterLayer);
        legend.style.display = 'block';
      } else {
        map.removeLayer(waterLayer);
        legend.style.display = 'none';
      }
    });
    
    document.getElementById('monitoringToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        if (monitoringSitesLayer) map.addLayer(monitoringSitesLayer);
      } else {
        if (monitoringSitesLayer) map.removeLayer(monitoringSitesLayer);
      }
    });
    
    document.getElementById('waterbodyToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        if (waterbodyLayer) map.addLayer(waterbodyLayer);
      } else {
        if (waterbodyLayer) map.removeLayer(waterbodyLayer);
      }
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>UK Geological Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 100vh; }
    .layer-control {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="layer-control">
    <label>
      <input type="checkbox" id="bgsToggle" checked> BGS Hydrogeology
    </label>
    <br>
    <label>
      <input type="checkbox" id="waterToggle" checked> Water Availability at Q95
    </label>
    <div id="waterLegend" style="margin-top: 10px;">
      <div><strong>Water Availability:</strong></div>
      <div id="legendItems"></div>
    </div>
  </div>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search)
    const lat = urlParams.get('lat')
    const lng = urlParams.get('lng')
    const postcode = urlParams.get('postcode')
    
    const map = L.map('map').setView([lat || 54.5, lng || -2.5], lat ? 12 : 6);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);
    
    // Add pin if coordinates are provided
    if (lat && lng) {
      const marker = L.marker([lat, lng]).addTo(map);
      marker.bindPopup(`<b>Postcode:</b> ${postcode || 'Unknown'}<br><b>Water Availability:</b> Loading...`);
      
      // Query layer metadata at pin location
      const queryMetadata = async () => {
        try {
          console.log('Fetching water availability for:', lat, lng);
          const response = await fetch(`/water-availability?lat=${lat}&lng=${lng}`);
          const data = await response.json();
          
          console.log('Water availability data:', data);
          
          let popupContent = `<b>Postcode:</b> ${postcode || 'Unknown'}<br>`;
          
          if (data.error) {
            popupContent += `<b>Water Availability:</b> ${data.error}`;
          } else {
            // Show all properties to see what's available
            popupContent += `<b>Properties:</b><br>`;
            for (const [key, value] of Object.entries(data)) {
              popupContent += `${key}: ${value}<br>`;
            }
            
            // Fetch and display waterbody features if ea_wb_id exists
            if (data.ea_wb_id) {
              try {
                const waterbodyResponse = await fetch(`/waterbody/${data.ea_wb_id}`);
                const waterbodyData = await waterbodyResponse.json();
                
                // Add waterbody features to map
                const waterbodyLayer = L.geoJSON(waterbodyData, {
                  style: {
                    color: '#0066cc',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.3
                  }
                }).addTo(map);
                
                // Extract waterbody feature names
                const featureNames = waterbodyData.features
                  .map(feature => feature.properties.name || feature.properties.NAME)
                  .filter(name => name)
                  .join(', ');
                
                if (featureNames) {
                  popupContent += `<b>Waterbody Features:</b> ${featureNames}<br>`;
                }
                
                console.log(`Added ${waterbodyData.features.length} waterbody features`);
              } catch (error) {
                console.error('Failed to load waterbody data:', error);
              }
            }
          }
          
          marker.setPopupContent(popupContent);
        } catch (error) {
          console.error('Metadata error:', error);
          marker.setPopupContent(`<b>Postcode:</b> ${postcode || 'Unknown'}<br>Error loading metadata`);
        }
      };
      
      queryMetadata();
    }
    
    const wmsLayer = L.tileLayer.wms('http://localhost:3000/wms', {
      layers: 'Hydrogeology',
      format: 'image/png',
      transparent: true,
      attribution: '© BGS',
      opacity: 1
    }).addTo(map);
    
    // Color mapping for water availability
    const colorMap = {
      'red': '#ff0000',
      'yellow': '#ffff00',
      'green': '#00ff00',
      'grey': '#808080',
      'unknown': '#cccccc'
    };
    
    function getColor(properties) {
      const value = properties.camscdsq95;
      const lowerValue = value ? value.toLowerCase() : 'unknown';
      return colorMap[lowerValue] || colorMap['unknown'];
    }
    
    // Build legend from color map
    const legendItems = document.getElementById('legendItems');
    Object.entries(colorMap).forEach(([label, color]) => {
      if (label !== 'unknown') {
        const item = document.createElement('div');
        item.style.cssText = 'display: flex; align-items: center; margin: 2px 0;';
        item.innerHTML = `<div style="width: 15px; height: 15px; background: ${color}; margin-right: 5px;"></div><span>${label}</span>`;
        legendItems.appendChild(item);
      }
    });
    
    // Load GeoJSON water availability data
    let waterGeoJsonLayer;
    fetch('/geojson/water-availability')
      .then(response => response.json())
      .then(data => {
        waterGeoJsonLayer = L.geoJSON(data, {
          style: feature => ({
            fillColor: getColor(feature.properties),
            weight: 1,
            opacity: 1,
            color: 'white',
            fillOpacity: 0.7
          }),
          onEachFeature: (feature, layer) => {
            const originalStyle = {
              fillColor: getColor(feature.properties),
              weight: 1,
              opacity: 1,
              color: 'white',
              fillOpacity: 0.7
            };
            
            layer.on('click', () => {
              let popupContent = '<b>Water Availability Data:</b><br>';
              for (const [key, value] of Object.entries(feature.properties)) {
                popupContent += `${key}: ${value}<br>`;
              }
              layer.bindPopup(popupContent).openPopup();
              layer.setStyle(originalStyle);
            });
          }
        }).addTo(map);
      });
    
    wmsLayer.on('tileerror', (e) => console.error('WMS tile error:', e));
    
    document.getElementById('bgsToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        map.addLayer(wmsLayer);
      } else {
        map.removeLayer(wmsLayer);
      }
    });
    
    document.getElementById('waterToggle').addEventListener('change', (e) => {
      const legend = document.getElementById('waterLegend');
      if (e.target.checked) {
        if (waterGeoJsonLayer) map.addLayer(waterGeoJsonLayer);
        legend.style.display = 'block';
      } else {
        if (waterGeoJsonLayer) map.removeLayer(waterGeoJsonLayer);
        legend.style.display = 'none';
      }
    });
  </script>
</body>
</html>

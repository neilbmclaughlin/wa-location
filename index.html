<!DOCTYPE html>
<html>
<head>
  <title>UK Geological Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 100vh; }
    .layer-control {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="layer-control">
    <label>
      <input type="checkbox" id="bgsToggle" checked> BGS Hydrogeology
    </label>
    <br>
    <label>
      <input type="checkbox" id="waterToggle" checked> Water Availability at Q95
    </label>
    <br>
    <label>
      <input type="checkbox" id="monitoringToggle"> Water Monitoring Sites
    </label>
    <div id="waterLegend" style="margin-top: 10px;">
      <div><strong>Water Availability:</strong></div>
      <div id="legendItems"></div>
    </div>
  </div>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search)
    const lat = urlParams.get('lat')
    const lng = urlParams.get('lng')
    const postcode = urlParams.get('postcode')
    
    const map = L.map('map').setView([lat || 54.5, lng || -2.5], lat ? 12 : 6);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);
    
    // Add pin if coordinates are provided
    if (lat && lng) {
      const marker = L.marker([lat, lng]).addTo(map);
      marker.bindPopup(`<b>Postcode:</b> ${postcode || 'Unknown'}<br><b>Water Availability:</b> Loading...`);
      
      // Query layer metadata at pin location
      const queryMetadata = async () => {
        try {
          console.log('Fetching polygons within 1km of:', lat, lng);
          
          // Get all water availability data
          const response = await fetch('/geojson/water-availability');
          const allData = await response.json();
          
          // Create 1km buffer around the point
          const centerPoint = turf.point([parseFloat(lng), parseFloat(lat)]);
          const buffered = turf.buffer(centerPoint, 1, {units: 'kilometers'});
          
          // Find all polygons that intersect with the 1km buffer
          const nearbyPolygons = allData.features.filter(feature => 
            turf.booleanIntersects(feature, buffered)
          );
          
          console.log(`Found ${nearbyPolygons.length} polygons within 1km`);
          
          let popupContent = `<b>Postcode:</b> ${postcode || 'Unknown'}<br>`;
          popupContent += `<b>Nearby Polygons:</b> ${nearbyPolygons.length}<br>`;
          
          // Collect all unique ea_wb_id values
          const waterbodyIds = [...new Set(
            nearbyPolygons
              .map(feature => feature.properties.ea_wb_id)
              .filter(id => id)
          )];
          
          console.log(`Found ${waterbodyIds.length} unique waterbody IDs`);
          
          // Fetch waterbody features for all IDs
          const waterbodyFeatures = [];
          for (const id of waterbodyIds) {
            try {
              const waterbodyResponse = await fetch(`/waterbody/${id}`);
              const waterbodyData = await waterbodyResponse.json();
              waterbodyFeatures.push(...waterbodyData.features);
            } catch (error) {
              console.error(`Failed to load waterbody ${id}:`, error);
            }
          }
          
          // Add all waterbody features to map as a single layer
          if (waterbodyFeatures.length > 0) {
            const waterbodyLayer = L.geoJSON(waterbodyFeatures, {
              style: {
                color: '#0066cc',
                weight: 2,
                opacity: 0.8,
                fillOpacity: 0.3
              }
            }).addTo(map);
            
            console.log(`Added ${waterbodyFeatures.length} waterbody features to map`);
            popupContent += `<b>Waterbody Features:</b> ${waterbodyFeatures.length}<br>`;
          }
          
          marker.setPopupContent(popupContent);
        } catch (error) {
          console.error('Metadata error:', error);
          marker.setPopupContent(`<b>Postcode:</b> ${postcode || 'Unknown'}<br>Error loading metadata`);
        }
      };
      
      queryMetadata();
    }
    
    const wmsLayer = L.tileLayer.wms('http://localhost:3000/wms', {
      layers: 'Hydrogeology',
      format: 'image/png',
      transparent: true,
      attribution: '© BGS',
      opacity: 1
    }).addTo(map);
    
    // Add monitoring sites layer using GeoJSON
    let monitoringSitesLayer;
    fetch('/monitoring-sites-geojson')
      .then(response => response.json())
      .then(data => {
        monitoringSitesLayer = L.geoJSON(data, {
          pointToLayer: (feature, latlng) => {
            return L.circleMarker(latlng, {
              radius: 4,
              fillColor: '#ff7800',
              color: '#000',
              weight: 1,
              opacity: 1,
              fillOpacity: 0.8
            });
          },
          onEachFeature: (feature, layer) => {
            if (feature.properties) {
              let popupContent = '<b>Monitoring Site:</b><br>';
              for (const [key, value] of Object.entries(feature.properties)) {
                popupContent += `${key}: ${value}<br>`;
              }
              layer.bindPopup(popupContent);
            }
          }
        });
      });
    
    // Color mapping for water availability
    const colorMap = {
      'red': '#ff0000',
      'yellow': '#ffff00',
      'green': '#00ff00',
      'grey': '#808080',
      'unknown': '#cccccc'
    };
    
    function getColor(properties) {
      const value = properties.camscdsq95;
      const lowerValue = value ? value.toLowerCase() : 'unknown';
      return colorMap[lowerValue] || colorMap['unknown'];
    }
    
    // Build legend from color map
    const legendItems = document.getElementById('legendItems');
    Object.entries(colorMap).forEach(([label, color]) => {
      if (label !== 'unknown') {
        const item = document.createElement('div');
        item.style.cssText = 'display: flex; align-items: center; margin: 2px 0;';
        item.innerHTML = `<div style="width: 15px; height: 15px; background: ${color}; margin-right: 5px;"></div><span>${label}</span>`;
        legendItems.appendChild(item);
      }
    });
    
    // Load GeoJSON water availability data
    let waterGeoJsonLayer;
    fetch('/geojson/water-availability')
      .then(response => response.json())
      .then(data => {
        waterGeoJsonLayer = L.geoJSON(data, {
          style: feature => ({
            fillColor: getColor(feature.properties),
            weight: 1,
            opacity: 1,
            color: 'white',
            fillOpacity: 0.7
          }),
          onEachFeature: (feature, layer) => {
            const originalStyle = {
              fillColor: getColor(feature.properties),
              weight: 1,
              opacity: 1,
              color: 'white',
              fillOpacity: 0.7
            };
            
            layer.on('click', async () => {
              let popupContent = '<b>Water Availability Data:</b><br>';
              for (const [key, value] of Object.entries(feature.properties)) {
                popupContent += `${key}: ${value}<br>`;
              }
              
              // Fetch and display waterbody feature names if ea_wb_id exists
              if (feature.properties.ea_wb_id) {
                try {
                  const waterbodyResponse = await fetch(`/waterbody/${feature.properties.ea_wb_id}`);
                  const waterbodyData = await waterbodyResponse.json();
                  
                  // Extract waterbody feature names
                  const featureNames = waterbodyData.features
                    .map(feature => feature.properties.name || feature.properties.NAME)
                    .filter(name => name);
                  
                  if (featureNames.length > 0) {
                    popupContent += `<b>Waterbody Features:</b><br>`;
                    featureNames.forEach(name => {
                      popupContent += `• ${name}<br>`;
                    });
                  }
                } catch (error) {
                  console.error('Failed to load waterbody data:', error);
                }
              }
              
              layer.bindPopup(popupContent).openPopup();
              layer.setStyle(originalStyle);
            });
          }
        }).addTo(map);
      });
    
    wmsLayer.on('tileerror', (e) => console.error('WMS tile error:', e));
    
    document.getElementById('bgsToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        map.addLayer(wmsLayer);
      } else {
        map.removeLayer(wmsLayer);
      }
    });
    
    document.getElementById('waterToggle').addEventListener('change', (e) => {
      const legend = document.getElementById('waterLegend');
      if (e.target.checked) {
        if (waterGeoJsonLayer) map.addLayer(waterGeoJsonLayer);
        legend.style.display = 'block';
      } else {
        if (waterGeoJsonLayer) map.removeLayer(waterGeoJsonLayer);
        legend.style.display = 'none';
      }
    });
    
    document.getElementById('monitoringToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        map.addLayer(monitoringSitesLayer);
      } else {
        map.removeLayer(monitoringSitesLayer);
      }
    });
  </script>
</body>
</html>

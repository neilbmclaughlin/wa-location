<!DOCTYPE html>
<html>
<head>
  <title>UK Geological Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 100vh; }
    .layer-control {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 1000;
    }
    .back-btn {
      display: inline-block;
      padding: 5px 10px;
      background: #007cba;
      color: white;
      text-decoration: none;
      border-radius: 3px;
      font-size: 12px;
      margin-bottom: 10px;
    }
    .back-btn:hover { background: #005a8b; }
  </style>
</head>
<body>
  <div class="layer-control">
    <a href="/" class="back-btn">← Back to Search</a>
    <div style="margin-top: 10px;">
      <label>
        <input type="checkbox" id="bgsToggle"> BGS Hydrogeology
      </label>
      <br>
      <label>
        <input type="checkbox" id="waterToggle" checked> Water Availability at Q95
      </label>
      <br>
      <label style="margin-left: 20px;">
        <input type="checkbox" id="boundaryToggle"> Show Boundaries
      </label>
      <br>
      <label>
        <input type="checkbox" id="monitoringToggle"> Water Monitoring Sites
      </label>
      <br>
      <label>
        <input type="checkbox" id="waterbodyToggle" checked> Waterbody Features
      </label>
      <div id="waterLegend" style="margin-top: 10px;">
        <div><strong>Water Availability:</strong></div>
        <div id="legendItems"></div>
      </div>
    </div>
  </div>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search)
    const lat = urlParams.get('lat')
    const lng = urlParams.get('lng')
    const postcode = urlParams.get('postcode')
    const catchment = urlParams.get('catchment')
    const layers = urlParams.get('layers')
    
    const map = L.map('map').setView([lat || 54.5, lng || -2.5], catchment ? 15 : (lat ? 12 : 6));
    
    // Add scale control
    L.control.scale().addTo(map);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);
    
    // Set initial layer states based on URL parameters
    if (layers === 'waterbody') {
      document.getElementById('waterToggle').checked = false;
      document.getElementById('waterbodyToggle').checked = true;
      document.getElementById('monitoringToggle').checked = false;
      document.getElementById('bgsToggle').checked = false;
      document.getElementById('boundaryToggle').checked = false;
    }
    
    // Add pin if coordinates are provided
    if (lat && lng) {
      const marker = L.marker([lat, lng]).addTo(map);
      marker.bindPopup(`<b>Postcode:</b> ${postcode || 'Unknown'}<br><b>Water Availability:</b> Loading...`);
      
      // Query layer metadata at pin location
      const queryMetadata = async () => {
        try {
          console.log('Fetching polygons within 1km of:', lat, lng);
          
          // Get all polygons within 1km using WFS
          const response = await fetch(`/nearby-catchments?lat=${lat}&lng=${lng}&radius=1000`);
          const data = await response.json();
          
          let popupContent = `<b>Postcode:</b> ${postcode || 'Unknown'}<br>`;
          
          if (data.features && data.features.length > 0) {
            popupContent += `<b>Nearby Polygons:</b> ${data.features.length}<br>`;
            
            // Collect all unique ea_wb_id values
            const waterbodyIds = [...new Set(
              data.features
                .map(feature => feature.properties.ea_wb_id)
                .filter(id => id)
            )];
            
            // Fetch waterbody features for all IDs
            waterbodyFeatures = []; // Reset global array
            for (const id of waterbodyIds) {
              try {
                const waterbodyResponse = await fetch(`/waterbody/${id}`);
                const waterbodyData = await waterbodyResponse.json();
                waterbodyFeatures.push(...waterbodyData.features);
              } catch (error) {
                console.error(`Failed to load waterbody ${id}:`, error);
              }
            }
            
            // Add all waterbody features to map as a single layer
            if (waterbodyFeatures.length > 0) {
              waterbodyLayer = L.geoJSON(waterbodyFeatures, {
                style: (feature) => {
                  const geometryType = feature.properties['geometry-type'];
                  const type = geometryType ? geometryType.split('/').pop() : '';
                  const featureName = feature.properties.name || feature.properties.NAME;
                  const isSelected = catchment && featureName === catchment;
                  
                  if (type === 'Catchment') {
                    return {
                      color: isSelected ? '#ff6600' : '#000000',
                      weight: isSelected ? 4 : 2,
                      opacity: 0.8,
                      fillColor: isSelected ? '#ff6600' : 'transparent',
                      fillOpacity: isSelected ? 0.2 : 0.1
                    };
                  } else if (type === 'RiverLine') {
                    return {
                      color: '#0066cc',
                      weight: 3,
                      opacity: 0.8,
                      fillOpacity: 0
                    };
                  } else {
                    return {
                      color: '#0066cc',
                      weight: 2,
                      opacity: 0.8,
                      fillOpacity: 0.3
                    };
                  }
                },
                onEachFeature: (feature, layer) => {
                  const geometryType = feature.properties['geometry-type'];
                  const type = geometryType ? geometryType.split('/').pop() : '';
                  const featureName = feature.properties.name || feature.properties.NAME;
                  
                  if (type === 'Catchment' && featureName) {
                    const center = layer.getBounds().getCenter();
                    const labelMarker = L.marker(center, {
                      icon: L.divIcon({
                        className: 'catchment-label',
                        html: `<div style="background: rgba(255,255,255,0.8); padding: 2px 4px; border-radius: 3px; font-size: 12px; font-weight: bold; border: 1px solid #333;">${featureName}</div>`,
                        iconSize: [100, 20],
                        iconAnchor: [50, 10]
                      })
                    }).addTo(map);
                    catchmentLabels.push(labelMarker); // Track the label marker
                  }
                }
              });
              
              if (document.getElementById('waterbodyToggle').checked) {
                waterbodyLayer.addTo(map);
              }
              
              // If a specific catchment is selected, zoom to its bounds
              if (catchment) {
                const selectedFeature = waterbodyFeatures.find(f => {
                  const featureName = f.properties.name || f.properties.NAME;
                  const geometryType = f.properties['geometry-type'];
                  const type = geometryType ? geometryType.split('/').pop() : '';
                  return featureName === catchment && type === 'Catchment';
                });
                
                if (selectedFeature) {
                  const featureLayer = L.geoJSON(selectedFeature);
                  map.fitBounds(featureLayer.getBounds(), { padding: [20, 20] });
                }
              }
              
              console.log(`Added ${waterbodyFeatures.length} waterbody features to map`);
              popupContent += `<b>Waterbody Features:</b> ${waterbodyFeatures.length}<br>`;
            }
          } else {
            popupContent += `<b>Water Availability:</b> No polygons found within 1km`;
          }
          
          marker.setPopupContent(popupContent);
        } catch (error) {
          console.error('Metadata error:', error);
          marker.setPopupContent(`<b>Postcode:</b> ${postcode || 'Unknown'}<br>Error loading metadata`);
        }
      };
      
      queryMetadata();
    }
    
    const hydrologyWmsLayer = L.tileLayer.wms('/hydrology-wms', {
      layers: 'Hydrogeology',
      format: 'image/png',
      transparent: true,
      attribution: '© BGS',
      opacity: 1
    });
    
    // Add monitoring sites layer using GeoJSON
    let monitoringSitesLayer;
    let waterbodyLayer;
    let catchmentLabels = []; // Track catchment label markers
    let waterbodyFeatures = []; // Store waterbody features globally
    fetch('/monitoring-sites')
      .then(response => response.json())
      .then(data => {
        monitoringSitesLayer = L.geoJSON(data, {
          pointToLayer: (feature, latlng) => {
            return L.circleMarker(latlng, {
              radius: 4,
              fillColor: '#ff7800',
              color: '#000',
              weight: 1,
              opacity: 1,
              fillOpacity: 0.8,
              pane: 'markerPane'
            });
          },
          onEachFeature: (feature, layer) => {
            if (feature.properties) {
              let popupContent = '<b>Monitoring Site:</b><br>';
              for (const [key, value] of Object.entries(feature.properties)) {
                popupContent += `${key}: ${value}<br>`;
              }
              layer.bindPopup(popupContent);
            }
          }
        });
      });
    
    // Color mapping for water availability
    const colorMap = {
      'red': '#ff0000',
      'yellow': '#ffff00',
      'green': '#00ff00',
      'grey': '#808080',
      'unknown': '#cccccc'
    };
    
    function getColor(properties) {
      const value = properties.camscdsq95;
      const lowerValue = value ? value.toLowerCase() : 'unknown';
      return colorMap[lowerValue] || colorMap['unknown'];
    }
    
    // Build legend from color map
    const legendItems = document.getElementById('legendItems');
    Object.entries(colorMap).forEach(([label, color]) => {
      if (label !== 'unknown') {
        const item = document.createElement('div');
        item.style.cssText = 'display: flex; align-items: center; margin: 2px 0;';
        item.innerHTML = `<div style="width: 15px; height: 15px; background: ${color}; margin-right: 5px;"></div><span>${label}</span>`;
        legendItems.appendChild(item);
      }
    });
    
    // Load water availability as WMS layer
    const waterAvailabilityWmsLayer = L.tileLayer.wms('/water-availability-wms', {
      layers: 'Resource_Availability_at_Q95',
      styles: 'ResourceAvailability_at_Q95_04_25',
      format: 'image/png',
      transparent: true,
      attribution: '© Environment Agency',
      opacity: 0.7
    });
    
    // Add water layer based on URL parameters
    if (layers !== 'waterbody') {
      waterAvailabilityWmsLayer.addTo(map);
    }
    
    // Add WFS boundary overlay for polygon outlines
    let boundaryLayer;
    const addBoundaryLayer = async () => {
      // Only show boundaries at zoom level 10 or higher
      if (map.getZoom() < 10 || !document.getElementById('boundaryToggle').checked) {
        if (boundaryLayer) {
          map.removeLayer(boundaryLayer);
          boundaryLayer = null;
        }
        return;
      }
      
      try {
        const bounds = map.getBounds();
        const response = await fetch(`/water-availability-wfs?SERVICE=WFS&VERSION=2.0.0&REQUEST=GetFeature&TYPENAME=Resource_Availability_at_Q95&OUTPUTFORMAT=application/json&SRSNAME=EPSG:4326&BBOX=${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()},EPSG:4326`);
        const data = await response.json();
        
        if (boundaryLayer) map.removeLayer(boundaryLayer);
        
        boundaryLayer = L.geoJSON(data, {
          style: {
            color: '#333333',
            weight: 1,
            opacity: 0.8,
            fillOpacity: 0 // transparent fill, outline only
          }
        }).addTo(map);
      } catch (error) {
        console.error('Failed to load boundary layer:', error);
      }
    };
    
    // Update boundaries when map moves
    map.on('moveend zoomend', addBoundaryLayer);
    
    // Add click handler for GetFeatureInfo
    map.on('click', async (e) => {
      const bounds = map.getBounds();
      const size = map.getSize();
      const point = map.latLngToContainerPoint(e.latlng);
      
      try {
        const url = `/water-availability-info?bbox=${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}&width=${size.x}&height=${size.y}&x=${Math.round(point.x)}&y=${Math.round(point.y)}`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.features && data.features.length > 0) {
          const feature = data.features[0];
          let popupContent = '<b>Water Availability Data:</b><br>';
          
          for (const [key, value] of Object.entries(feature.properties)) {
            popupContent += `${key}: ${value}<br>`;
          }
          
          // Fetch waterbody features if ea_wb_id exists
          if (feature.properties.ea_wb_id) {
            try {
              const waterbodyResponse = await fetch(`/waterbody/${feature.properties.ea_wb_id}`);
              const waterbodyData = await waterbodyResponse.json();
              
              // Extract waterbody feature names with geometry types and distances
              const postcodePoint = turf.point([parseFloat(lng), parseFloat(lat)]);
              const featureNames = waterbodyData.features
                .map(f => {
                  const name = f.properties.name || f.properties.NAME;
                  const geometryType = f.properties['geometry-type'];
                  const type = geometryType ? geometryType.split('/').pop() : '';
                  
                  if (name && f.geometry) {
                    // Calculate distance from postcode to feature
                    let distance;
                    if (f.geometry.type === 'Point') {
                      // direct distance calc
                      distance = turf.distance(postcodePoint, f.geometry, {units: 'meters'});
                    } else if (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString') {
                      // For lines, find nearest point on the line
                      const nearestPoint = turf.nearestPointOnLine(f.geometry, postcodePoint);
                      distance = turf.distance(postcodePoint, nearestPoint, {units: 'meters'});
                    } else if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
                      // For polygons, calculate distance to nearest polygon boundary
                      distance = turf.pointToLineDistance(postcodePoint, turf.polygonToLine(f.geometry), {units: 'meters'});
                    } else {
                      // Fallback: distance to centroid
                      const centroid = turf.centroid(f.geometry);
                      distance = turf.distance(postcodePoint, centroid, {units: 'meters'});
                    }
                    
                    const distanceText = distance < 1000 ? 
                      `${Math.round(distance)}m` : 
                      `${(distance/1000).toFixed(1)}km`;
                    
                    return `${name} (${type}) - ${distanceText}`;
                  }
                  return null;
                })
                .filter(name => name);
              
              if (featureNames.length > 0) {
                popupContent += `<b>Waterbody Features:</b><br>`;
                featureNames.forEach(name => {
                  popupContent += `• ${name}<br>`;
                });
              }
            } catch (error) {
              console.error('Failed to load waterbody data:', error);
            }
          }
          
          L.popup().setLatLng(e.latlng).setContent(popupContent).openOn(map);
        } else {
          // Show a popup indicating no data found
          L.popup().setLatLng(e.latlng).setContent('<b>No water availability data found at this location</b>').openOn(map);
        }
      } catch (error) {
        console.error('GetFeatureInfo error:', error);
      }
    });
    
    hydrologyWmsLayer.on('tileerror', (e) => console.error('WMS tile error:', e));
    
    document.getElementById('bgsToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        map.addLayer(hydrologyWmsLayer);
      } else {
        map.removeLayer(hydrologyWmsLayer);
      }
    });
    
    document.getElementById('waterToggle').addEventListener('change', (e) => {
      const legend = document.getElementById('waterLegend');
      if (e.target.checked) {
        map.addLayer(waterAvailabilityWmsLayer);
        legend.style.display = 'block';
      } else {
        map.removeLayer(waterAvailabilityWmsLayer);
        legend.style.display = 'none';
      }
    });
    
    document.getElementById('monitoringToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        if (monitoringSitesLayer) map.addLayer(monitoringSitesLayer);
      } else {
        if (monitoringSitesLayer) map.removeLayer(monitoringSitesLayer);
      }
    });
    
    document.getElementById('waterbodyToggle').addEventListener('change', (e) => {
      if (e.target.checked) {
        if (waterbodyLayer) map.addLayer(waterbodyLayer);
        // Recreate catchment labels
        if (waterbodyFeatures) {
          waterbodyFeatures.forEach(f => {
            const geometryType = f.properties['geometry-type'];
            const type = geometryType ? geometryType.split('/').pop() : '';
            const featureName = f.properties.name || f.properties.NAME;
            
            if (type === 'Catchment' && featureName && f.geometry) {
              const center = turf.centroid(f.geometry).geometry.coordinates;
              const labelMarker = L.marker([center[1], center[0]], {
                icon: L.divIcon({
                  className: 'catchment-label',
                  html: `<div style="background: rgba(255,255,255,0.8); padding: 2px 4px; border-radius: 3px; font-size: 12px; font-weight: bold; border: 1px solid #333;">${featureName}</div>`,
                  iconSize: [100, 20],
                  iconAnchor: [50, 10]
                })
              }).addTo(map);
              catchmentLabels.push(labelMarker);
            }
          });
        }
      } else {
        if (waterbodyLayer) map.removeLayer(waterbodyLayer);
        // Remove catchment labels
        catchmentLabels.forEach(label => map.removeLayer(label));
        catchmentLabels = [];
      }
    });
    
    document.getElementById('boundaryToggle').addEventListener('change', (e) => {
      addBoundaryLayer(); // Will check the toggle state inside the function
    });
  </script>
</body>
</html>
